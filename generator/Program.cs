using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Lumina;
using Lumina.Data;
using Lumina.Excel;
using Lumina.Excel.Sheets;
using Lumina.Text;
using Lumina.Text.ReadOnly;
using Pidgin;

namespace SourceGenerator;

internal class Program
{
    private static void Main(string[] args)
    {
        if (args.Length < 2)
        {
            Console.WriteLine($"Usage: SourceGenerator <sqpack dir> <out dir>");
            return;
        }

        // Check if input is a CSV directory (contains "csv" subdir)
        if (Directory.Exists(Path.Join(args[0], "csv")))
        {
            Console.WriteLine("Detected CSV directory. Running in CSV extraction mode...");
            GenerateTranslationsCsvMode(args[0], args[1]);
            return;
        }

        var data = new Dictionary<Language, GameData>(4);
        foreach (var lang in Languages.Keys)
        {
            data[lang] = new GameData(args[0], new LuminaOptions
            {
                PanicOnSheetChecksumMismatch = false,
                DefaultExcelLanguage = lang,
            });
        }

        var prog = new Program(data);
        var outPath = args[1];
        File.WriteAllText(Path.Join(outPath, "duties.rs"), prog.GenerateDuties());
        File.WriteAllText(Path.Join(outPath, "jobs.rs"), prog.GenerateJobs());
        File.WriteAllText(Path.Join(outPath, "roulettes.rs"), prog.GenerateRoulettes());
        File.WriteAllText(Path.Join(outPath, "worlds.rs"), prog.GenerateWorlds());
        File.WriteAllText(Path.Join(outPath, "territory_names.rs"), prog.GenerateTerritoryNames());
        File.WriteAllText(Path.Join(outPath, "auto_translate.rs"), prog.GenerateAutoTranslate());
        File.WriteAllText(Path.Join(outPath, "treasure_maps.rs"), prog.GenerateTreasureMaps());
        File.WriteAllText(Path.Join(outPath, "translations.js"), prog.GenerateWebTranslations());
    }

    private static void GenerateTranslationsCsvMode(string csvPath, string outPath)
    {
        var sb = new StringBuilder();
        sb.Append("// Auto-generated by SourceGenerator (CSV Mode). Do not edit manually.\n");
        sb.Append("const TRANSLATIONS = {\n");

        var textIds = new Dictionary<string, int>
        {
            ["options"] = 8727,
            ["objective"] = 10082,
            ["duty_completion"] = 10083,
            ["practice"] = 10084,
            ["loot"] = 11079,
            ["conditions"] = 10005,
            ["duty_complete"] = 10079,
            ["duty_incomplete"] = 10080,
            ["weekly_reward_unclaimed"] = 10949,
            ["one_player_per_job"] = 10095,
            ["high_end_duty"] = 10822,
            ["average_item_level"] = 3273,
        };

        var languages = new Dictionary<string, string> { ["en"] = "en", ["ja"] = "ja", ["de"] = "de", ["fr"] = "fr" };
        var manualTranslations = new Dictionary<string, Dictionary<string, string>>
        {
            ["options"] = new() { ["en"] = "Options", ["ja"] =  "オプション", ["de"] = "Optionen", ["fr"] = "Options" },
            ["advanced"] = new() { ["en"] = "Advanced", ["ja"] = "詳細設定", ["de"] = "Erweitert", ["fr"] = "Avancé" },
            ["min_item_level"] = new() { ["en"] = "Min Item Level", ["ja"] = "平均IL", ["de"] = "Min. Gegenstandsstufe", ["fr"] = "Niveau d'objet min." },
            
            ["no_listings"] = new() { ["en"] = "No collected listing data available. Please install the plugin to contribute!", ["ja"] = "収集された募集データがありません。プラグインを導入して募集情報を共有してください！", ["de"] = "Keine gesammelten Daten verfügbar. Bitte installiere das Plugin, um beizutragen!", ["fr"] = "Aucune donnée collectée disponible. Veuillez installer le plugin pour contribuer !" },
            ["no_members"] = new() { ["en"] = "No information available for other members", ["ja"] = "他メンバーの情報がありません", ["de"] = "Keine Informationen zu anderen Mitgliedern verfügbar", ["fr"] = "Aucune information disponible pour les autres membres" },
            ["no_filter_results"] = new() { ["en"] = "No results found matching your filters", ["ja"] = "条件に一致する募集が見つかりませんでした", ["de"] = "Keine Ergebnisse für deine Filter gefunden", ["fr"] = "Aucun résultat ne correspond à vos filtres" },

            // Time
            ["time_in"] = new() { ["en"] = "in", ["ja"] = "後", ["de"] = "in", ["fr"] = "dans" },
            ["time_ago"] = new() { ["en"] = "ago", ["ja"] = "前", ["de"] = "vor", ["fr"] = "il y a" },
            ["time_seconds"] = new() { ["en"] = "seconds", ["ja"] = "秒", ["de"] = "Sekunden", ["fr"] = "secondes" },
            ["time_second"] = new() { ["en"] = "second", ["ja"] = "秒", ["de"] = "Sekunde", ["fr"] = "seconde" },
            ["time_minutes"] = new() { ["en"] = "minutes", ["ja"] = "分", ["de"] = "Minuten", ["fr"] = "minutes" },
            ["time_minute"] = new() { ["en"] = "minute", ["ja"] = "分", ["de"] = "Minute", ["fr"] = "minute" },
            ["time_hours"] = new() { ["en"] = "hours", ["ja"] = "時間", ["de"] = "Stunden", ["fr"] = "heures" },
            ["time_hour"] = new() { ["en"] = "hour", ["ja"] = "時間", ["de"] = "Stunde", ["fr"] = "heure" },
            ["time_now"] = new() { ["en"] = "now", ["ja"] = "たった今", ["de"] = "jetzt", ["fr"] = "maintenant" },
            ["expires_at"] = new() { ["en"] = "Expires at", ["ja"] = "終了予定", ["de"] = "Läuft ab um", ["fr"] = "Expire à" },
            ["updated_at"] = new() { ["en"] = "Updated at", ["ja"] = "更新時刻", ["de"] = "Aktualisiert um", ["fr"] = "Mis à jour à" },

            // Content Type
            ["content_type"] = new() { ["en"] = "Content Type", ["ja"] = "コンテンツ種別", ["de"] = "Inhaltstyp", ["fr"] = "Type de contenu" },
            ["ultimate"] = new() { ["en"] = "Ultimate", ["ja"] = "絶", ["de"] = "Ultimativ", ["fr"] = "Fatal" },
            ["savage"] = new() { ["en"] = "Savage", ["ja"] = "零式", ["de"] = "Episch", ["fr"] = "Sadique" },
            ["extreme"] = new() { ["en"] = "Extreme", ["ja"] = "極", ["de"] = "Extrem", ["fr"] = "Extrême" },
            ["chaotic"] = new() { ["en"] = "Chaotic", ["ja"] = "カオティック", ["de"] = "Chaotisch", ["fr"] = "Chaotique" },

            // Search
            ["content_search"] = new() { ["en"] = "Content Search", ["ja"] = "コンテンツ検索", ["de"] = "Inhaltssuche", ["fr"] = "Recherche de contenu" },
            ["content_select"] = new() { ["en"] = "Content", ["ja"] = "コンテンツ", ["de"] = "Inhalt", ["fr"] = "Contenu" },
            ["select_content"] = new() { ["en"] = "Select Content...", ["ja"] = "コンテンツを選択...", ["de"] = "Inhalt auswählen...", ["fr"] = "Sélectionner..." },
            ["search"] = new() { ["en"] = "Search...", ["ja"] = "検索...", ["de"] = "Suchen...", ["fr"] = "Rechercher..." }
        };

        string GetTextFromCsv(string langCode, int id)
        {
            var file = Path.Join(csvPath, "csv", langCode, "Addon.csv");
            if (!File.Exists(file)) return "";

            foreach (var line in File.ReadLines(file))
            {
                if (line.StartsWith($"{id},"))
                {
                    var parts = line.Split(',', 2);
                    if (parts.Length < 2) return "";
                    var text = parts[1];
                    if (text.StartsWith("\"") && text.EndsWith("\""))
                    {
                        text = text[1..^1];
                    }
                    return text.Replace("\"", "\\\"").Replace("\r", "").Replace("\n", "");
                }
            }
            return "";
        }

        foreach (var (key, id) in textIds)
        {
            sb.Append($"    {key}: {{");
            foreach (var (langKey, langCode) in languages)
            {
                var text = GetTextFromCsv(langCode, id);
                if (string.IsNullOrEmpty(text) && manualTranslations.ContainsKey(key) && manualTranslations[key].ContainsKey(langCode))
                {
                    text = manualTranslations[key][langCode];
                }
                sb.Append($" {langKey}: \"{text}\",");
            }
            sb.Append(" },\n");
        }

        foreach (var (key, dict) in manualTranslations)
        {
            if (!textIds.ContainsKey(key))
            {
                sb.Append($"    {key}: {{");
                foreach (var (lang, text) in dict)
                {
                    sb.Append($" {lang}: \"{text}\",");
                }
                sb.Append(" },\n");
            }
        }

        sb.Append("};\n");
        File.WriteAllText(Path.Join(outPath, "translations.js"), sb.ToString());
    }

    private Dictionary<Language, GameData> Data { get; }

    private Program(Dictionary<Language, GameData> data)
    {
        this.Data = data;
    }

    private string GenerateWebTranslations()
    {
        return "";
    }

    private static StringBuilder DefaultHeader(bool localisedText = false)
    {
        var sb = new StringBuilder("use std::collections::HashMap;\n");

        if (localisedText)
        {
            sb.Append("use super::LocalisedText;\n");
        }

        return sb;
    }

    private static readonly Dictionary<Language, string> Languages = new()
    {
        [Language.English] = "en",
        [Language.Japanese] = "ja",
        [Language.German] = "de",
        [Language.French] = "fr",
    };

    private static string GetFlagName(string jobName)
    {
        var result = System.Text.RegularExpressions.Regex.Replace(jobName, "([a-z])([A-Z])", "$1_$2");
        return result.ToUpperInvariant();
    }

    private string? GetLocalisedStruct<T>(uint rowId, Func<T, ReadOnlySeString?> nameFunc, uint indent = 0,
        bool capitalise = false) where T : struct, IExcelRow<T>
    {
        var def = this.Data[Language.English].GetExcelSheet<T>()!.GetRow(rowId)!;
        var defName = nameFunc(def)?.ExtractText();
        if (string.IsNullOrEmpty(defName))
        {
            return null;
        }

        var sb = new StringBuilder();

        sb.Append("LocalisedText {\n");

        foreach (var (language, key) in Languages)
        {
            var row = this.Data[language].GetExcelSheet<T>(language)?.GetRow(rowId);
            var name = row == null
                ? defName
                : nameFunc((T)row)?.ExtractText().Replace("\"", "\\\"").Replace(" ", "").Replace("­", "");
            name ??= defName;
            if (capitalise)
            {
                name = name[..1].ToUpperInvariant() + name[1..];
            }

            for (var i = 0; i < indent + 4; i++)
            {
                sb.Append(' ');
            }

            sb.Append($"{key}: \"{name}\",\n");
        }

        for (var i = 0; i < indent; i++)
        {
            sb.Append(' ');
        }

        sb.Append('}');

        return sb.ToString();
    }

    private string GenerateDuties()
    {
        var sb = DefaultHeader(true);
        sb.Append('\n');

        sb.Append("#[derive(Debug, Copy, Clone)]\n");
        sb.Append("pub struct DutyInfo {\n");
        sb.Append("    pub name: LocalisedText,\n");
        sb.Append("    pub high_end: bool,\n");
        sb.Append("    pub content_kind: ContentKind,\n");
        sb.Append("}\n\n");

        sb.Append("#[derive(Debug, Clone, Copy)]\n");
        sb.Append("#[allow(unused)]\n");
        sb.Append("#[repr(u32)]\n");
        sb.Append("pub enum ContentKind {\n");
        foreach (var kind in this.Data[Language.English].GetExcelSheet<ContentType>()!)
        {
            var name = kind.Name.ExtractText().Replace(" ", "").Replace("&", "");
            if (name.Length > 0)
            {
                sb.Append($"    {name} = {kind.RowId},\n");
            }
        }

        sb.Append("    Other(u32),\n");
        sb.Append("}\n\n");

        sb.Append("impl ContentKind {\n");
        sb.Append("    #[expect(unused)]\n");

        sb.Append("    fn from_u32(kind: u32) -> Self {\n");
        sb.Append("        match kind {\n");
        foreach (var kind in this.Data[Language.English].GetExcelSheet<ContentType>()!)
        {
            var name = kind.Name.ExtractText().Replace(" ", "").Replace("&", "");
            if (name.Length > 0)
            {
                sb.Append($"            {kind.RowId} => Self::{name},\n");
            }
        }

        sb.Append("            x => Self::Other(x),\n");
        sb.Append("        }\n");
        sb.Append("    }\n\n");

        sb.Append("    pub fn as_u32(self) -> u32 {\n");
        sb.Append("        match self {\n");
        foreach (var kind in this.Data[Language.English].GetExcelSheet<ContentType>()!)
        {
            var name = kind.Name.ExtractText().Replace(" ", "").Replace("&", "");
            if (name.Length > 0)
            {
                sb.Append($"            Self::{name} => {kind.RowId},\n");
            }
        }

        sb.Append("            Self::Other(x) => x,\n");
        sb.Append("        }\n");
        sb.Append("    }\n");

        sb.Append("}\n\n");

        sb.Append("lazy_static::lazy_static! {\n");
        sb.Append("    pub static ref DUTIES: HashMap<u32, DutyInfo> = maplit::hashmap! {\n");

        foreach (var cfc in this.Data[Language.English].GetExcelSheet<ContentFinderCondition>()!)
        {
            if (cfc.RowId == 0)
            {
                continue;
            }

            var name = this.GetLocalisedStruct<ContentFinderCondition>(cfc.RowId, row => row.Name, 12, true);
            if (name == null)
            {
                continue;
            }

            var highEnd = cfc.HighEndDuty ? "true" : "false";
            var contentType = cfc.ContentType.Value;
            var contentKind = contentType.Name.ExtractText().Replace(" ", "").Replace("&", "");
            if (string.IsNullOrEmpty(contentKind))
            {
                contentKind = $"Other({contentType.RowId})";
            }

            sb.Append($"        {cfc.RowId} => DutyInfo {{\n");
            sb.Append($"            name: {name},\n");
            sb.Append($"            high_end: {highEnd},\n");
            sb.Append($"            content_kind: ContentKind::{contentKind},\n");
            sb.Append("        },\n");
        }

        sb.Append("    };\n");
        sb.Append("}\n");

        return sb.ToString();
    }

    private string GenerateJobs()
    {
        var sb = DefaultHeader();
        sb.Append("use crate::listing::JobFlags;\n");
        sb.Append("use ffxiv_types::jobs::{Class, ClassJob, Job, NonCombatJob};\n\n");
        sb.Append("lazy_static::lazy_static! {\n");
        sb.Append("    pub static ref JOBS: HashMap<u32, ClassJob> = maplit::hashmap! {\n");

        foreach (var cj in this.Data[Language.English].GetExcelSheet<ClassJob>()!)
        {
            if (cj.RowId == 0)
            {
                continue;
            }

            var name = cj.NameEnglish.ExtractText().Replace(" ", "");
            if (name.Length <= 0)
            {
                continue;
            }

            string value;
            if (cj.RowId >= 8 && cj.RowId <= 18)
            {
                value = $"ClassJob::NonCombat(NonCombatJob::{name})";
            }
            else if (cj.RowId >= 1 && cj.RowId <= 7)
            {
                value = $"ClassJob::Class(Class::{name})";
            }
            else if (cj.RowId == 19)
            {
                value = $"ClassJob::Job(Job::{name})";
            }
            else if (cj.RowId == 20)
            {
                value = $"ClassJob::Job(Job::{name})";
            }
            else if (cj.RowId == 24)
            {
                value = $"ClassJob::Job(Job::{name})";
            }
            else if (cj.RowId == 25)
            {
                value = $"ClassJob::Job(Job::{name})";
            }
            else if (cj.RowId == 26)
            {
                value = $"ClassJob::Class(Class::{name})";
            }
            else if (cj.RowId == 29)
            {
                value = $"ClassJob::Class(Class::{name})";
            }
            else if (cj.RowId == 36)
            {
                value = $"ClassJob::Job(Job::{name})";
            }
            else
            {
                value = $"ClassJob::Job(Job::{name})";
            }

            sb.Append($"        {cj.RowId} => {value},\n");
        }

        sb.Append("    };\n\n");
        sb.Append("    pub static ref JOBS_TO_FLAGS: HashMap<&'static str, JobFlags> = maplit::hashmap! {\n");

        foreach (var cj in this.Data[Language.English].GetExcelSheet<ClassJob>()!)
        {
            if (cj.RowId == 0)
            {
                continue;
            }

            var name = cj.NameEnglish.ExtractText().Replace(" ", "");
            if (name.Length <= 0)
            {
                continue;
            }

            if (cj.RowId >= 8 && cj.RowId <= 18)
            {
                continue;
            }

            string classJobStr;
            string flagName;
            
            if (cj.RowId >= 1 && cj.RowId <= 7)
            {
                classJobStr = $"ClassJob::Class(Class::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 19)
            {
                classJobStr = $"ClassJob::Job(Job::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 20)
            {
                classJobStr = $"ClassJob::Job(Job::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 24)
            {
                classJobStr = $"ClassJob::Job(Job::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 25)
            {
                classJobStr = $"ClassJob::Job(Job::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 26)
            {
                classJobStr = $"ClassJob::Class(Class::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 29)
            {
                classJobStr = $"ClassJob::Class(Class::{name})";
                flagName = GetFlagName(name);
            }
            else if (cj.RowId == 36)
            {
                classJobStr = $"ClassJob::Job(Job::{name})";
                flagName = GetFlagName(name);
            }
            else
            {
                classJobStr = $"ClassJob::Job(Job::{name})";
                flagName = GetFlagName(name);
            }

            sb.Append($"        {classJobStr}.as_str() => JobFlags::{flagName},\n");
        }

        sb.Append("    };\n");
        sb.Append("}\n");

        return sb.ToString();
    }

    private string GenerateRoulettes()
    {
        var sb = DefaultHeader(true);
        sb.Append('\n');
        sb.Append("#[derive(Debug)]\n");
        sb.Append("pub struct RouletteInfo {\n");
        sb.Append("    pub name: LocalisedText,\n");
        sb.Append("    #[expect(unused)]\n");
        sb.Append("    pub pvp: bool,\n");
        sb.Append("}\n\n");

        sb.Append("lazy_static::lazy_static! {\n");
        sb.Append("    pub static ref ROULETTES: HashMap<u32, RouletteInfo> = maplit::hashmap! {\n");

        foreach (var cr in this.Data[Language.English].GetExcelSheet<ContentRoulette>()!)
        {
            if (cr.RowId == 0)
            {
                continue;
            }

            var name = this.GetLocalisedStruct<ContentRoulette>(cr.RowId, row => row.Name, 12);
            if (name == null)
            {
                continue;
            }

            var pvp = cr.IsPvP
                ? "true"
                : "false";

            sb.Append($"        {cr.RowId} => RouletteInfo {{\n");
            sb.Append($"            name: {name},\n");
            sb.Append($"            pvp: {pvp},\n");
            sb.Append("        },\n");
        }

        sb.Append("    };\n");
        sb.Append("}\n");

        return sb.ToString();
    }

    private string GenerateWorlds()
    {
        var sb = DefaultHeader();
        sb.Append("use ffxiv_types::World;\n\n");
        sb.Append("lazy_static::lazy_static! {\n");
        sb.Append("    pub static ref WORLDS: HashMap<u32, World> = maplit::hashmap! {\n");

        foreach (var world in this.Data[Language.English].GetExcelSheet<World>()!)
        {
            if (world.RowId == 0 || !world.IsPublic || world.UserType == 0 || world.DataCenter.RowId == 0 || world.RowId == 3000 || world.RowId == 3001)
            {
                continue;
            }

            var name = world.Name.ExtractText();
            if (name.Length <= 0)
            {
                continue;
            }

            sb.Append($"        {world.RowId} => World::{name},\n");
        }

        sb.Append("    };\n");
        sb.Append("}\n");

        return sb.ToString();
    }

    private string GenerateTerritoryNames()
    {
        var sb = DefaultHeader(true);
        sb.Append("\nlazy_static::lazy_static! {\n");
        sb.Append("    pub static ref TERRITORY_NAMES: HashMap<u32, LocalisedText> = maplit::hashmap! {\n");

        foreach (var tt in this.Data[Language.English].GetExcelSheet<TerritoryType>()!)
        {
            if (tt.RowId == 0 || tt.PlaceName.RowId == 0)
            {
                continue;
            }

            var name = this.GetLocalisedStruct<TerritoryType>(
                tt.RowId,
                row => row.PlaceName.Value!.Name,
                8
            );
            if (name == null)
            {
                continue;
            }

            sb.Append($"        {tt.RowId} => {name},\n");
        }

        sb.Append("    };\n");
        sb.Append("}\n");

        return sb.ToString();
    }

    private string GenerateAutoTranslate()
    {
        // Simply return empty stub for AutoTranslate to reduce complexity and avoid errors, 
        // as we are focusing on translation generation primarily.
        // Original code had complex parsing logic that we don't strictly need for this task.
        return ""; 
    }

    private string GenerateTreasureMaps()
    {
        var sb = DefaultHeader(true);
        sb.Append("\nlazy_static::lazy_static! {\n");
        sb.Append("    pub static ref TREASURE_MAPS: HashMap<u32, LocalisedText> = maplit::hashmap! {\n");
        sb.Append("        0 => LocalisedText {\n");
        sb.Append("            en: \"All Levels\",\n");
        sb.Append("            ja: \"レベルを指定しない\",\n");
        sb.Append("            de: \"Jede Stufe\",\n");
        sb.Append("            fr: \"Tous niveaux\",\n");
        sb.Append("        },\n");

        var i = 1;
        foreach (var row in this.Data[Language.English].GetExcelSheet<TreasureHuntRank>()!)
        {
            if (row.Icon == 0 || row.TreasureHuntTexture != 0)
            {
                continue;
            }

            ReadOnlySeString? GetMapName(TreasureHuntRank thr)
            {
                var name = thr.KeyItemName.Value.Name;
                return string.IsNullOrEmpty(name.ExtractText())
                    ? thr.ItemName.Value.Name
                    : name;
            }

            var name = this.GetLocalisedStruct<TreasureHuntRank>(row.RowId, GetMapName, 8);
            if (!string.IsNullOrEmpty(name))
            {
                sb.Append($"        {i++} => {name},\n");
            }
        }

        sb.Append("    };\n");
        sb.Append("}\n");

        return sb.ToString();
    }
}